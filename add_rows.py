import time
import docker
import os
import psycopg
import random
import subprocess

def run():
    start_containers()
    try:
        wait_for_container("standby_db_instance", 30)
        add_rows()
        verify_sync()
    except Exception as e:
        raise e
    finally:
        close_containers()
        pass

def start_containers():
    # This will find a file called docker-compose.yaml in the current directory, and run it
    # using Docker Compose.  
    directory = os.path.dirname(os.path.realpath(__file__))
    compose_file = os.path.join(directory, "docker-compose.yaml")
    subprocess.run(["docker-compose", "-f", compose_file, "up", "-d"], check=True)

def is_ready(container_name="standby_db_instance", user="repuser", database="primary_database"):
    # This function takes in the name of a PostgreSQL container and uses the pg_isready function
    # to see if it is ready.  
    try:
        with psycopg.connect(host="localhost",
                            port="5433",
                            dbname="primary_database",
                            user="primary_username",
                            password="primary_password") as conn:

                with conn.cursor() as cur:
                    cur.execute("SELECT 1;")
    except psycopg.OperationalError as e:
        return False
    return True

def wait_for_container(container_name="standby_db_instance", timeout=30):
    # Waits until the container with the given name is ready.  Will raise an error if it takes
    # longer than timeout seconds for the container to start up.  
    start = time.time()
    while True:
        if is_ready(container_name=container_name, user="repuser", database="primary_database"):
            print(f"{container_name} is ready.  ")
            return
        if (time.time() - start) > timeout:
            raise RuntimeError(f"The container {container_name} took too long to start.  ")
        time.sleep(1)

def add_rows():
    # Connects to the database, creates a table named "numbers", then inserts 100 rows into 
    # the table.  
    conn = psycopg.connect(host="localhost",
                        port="5432",
                        dbname="primary_database",
                        user="primary_username",
                        password="primary_password")

    cur = conn.cursor()
    try:
        print("Creating a table to put rows into.  ")
        cur.execute("""
            CREATE TABLE IF NOT EXISTS numbers (
                id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                num1 INTEGER NOT NULL,
                num2 INTEGER NOT NULL
            );
        """)
    except Exception as e:
        conn.rollback()
        conn.close()
        raise e
    else:
        conn.commit()

    random_rows = [(random.randint(0, 9), random.randint(0, 9)) for i in range(100)]
    try:
        print("Inserting rows into the table.  ")
        cur.executemany("""
            INSERT INTO numbers (
                num1,
                num2
            ) VALUES (%s, %s);
        """, random_rows)
    except Exception as e:
        conn.rollback()
        cur.close()
        conn.close()
        raise e
    else:
        conn.commit()
        cur.close()
        conn.close()

def verify_sync(container_name="standby_db_instance", timeout=5):
    print("Verifying that the primary and standby databases were synchronized.  ")
    start = time.time()
    while True:
        # The port of the standby database is 5433 instead 5432 (which is the port of 
        # the primary database).  
        conn = psycopg.connect(host="localhost",
                                port="5433",
                                dbname="primary_database",
                                user="primary_username",
                                password="primary_password")

        cur = conn.cursor()
        rows = []
        try:
            cur.execute("""
                SELECT COUNT(*) FROM numbers;
            """)
            rows = cur.fetchall()[0][0]
            print("Number of rows:")
            print(rows)
            if rows == 100:
                print("The standby server synchronized correctly!")
                return
            elif rows > 100:
                print("The volumes must not have been deleted before running, because more than 100 rows were found.  Run 'docker-compose down -v' in the terminal to remove the volumes.  ")
                return
        except Exception as e:
            cur.close()
            conn.close()
            raise e
        finally:
            cur.close()
            conn.close()

        if (time.time() - start) > timeout:
            raise RuntimeError(f"The standby server is taking too long to synchronize with the primary server.  ")
        time.sleep(1)

def close_containers():
    # This will find a file called docker-compose.yaml in the current directory, and shut 
    # it down.  Note that this won't delete the volumes that store the actual data of the 
    # databases.  
    directory = os.path.dirname(os.path.realpath(__file__))
    compose_file = os.path.join(directory, "docker-compose.yaml")
    subprocess.run(["docker-compose", "-f", compose_file, "down"], check=True)
    print("Closed the containers.  ")

if __name__ == "__main__":
    run()